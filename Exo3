#include <iostream>
#include <cstdlib>
#include <fstream>
#include <cmath>
#include <time.h>
#include <ctime>

using namespace std;

double *prv(double *v,double a,int N)    //produit reel et vecteur
{
    for (int i=0;i<N;i++){
        v[i] *= a;
    }
    return v;
}
double *zero(int N) {
    double *b = new double [N];
    for (int i=0;i<N;i++){
        b[i]=0;
    }
    return b;
}

double **Zero(int N, int M) //créer une matrice de taille N*M remplie avec des zéros
{
    double **A = new double *[N];
    for (int i=0;i<N;i++){
        A[i] = new double [M];
        for(int j=0;j<M;j++){
            A[i][j]=0;
            
        }
    }
    return A;
}

double *av(double *u,double *v,int N)    // addition vectorielle
{
    double *r = zero(N);
    for (int i=0;i<N;i++){
        r[i] = u[i]+v[i]; 
    }
    return r;
}
void print_v(double*A,int N)
{
    cout<<"[";
    for( int i =0; i<N-1 ; i++){
        cout<<A[i]<<"," ;
    }
    cout<<A[N-1]<<"]";
}
void print_m(double**A,int N,int M)
{
    for( int i =0; i<N ; i++){
        cout<<"ligne"<<i<<": " ;
        for ( int j =0; j<M ; j++){
            cout<<A[i][j]<<" " ;
        }
    cout<<endl ;
    }
}

double*F(double*V,double M, double G){
    // M=masse de la terre, G=Constante de gravitation universelle
    double*U=zero(4);
    U[0]=V[2];
    U[1]=V[3];
    U[2]=-M*G*(V[0]/pow(sqrt(V[0]*V[0]+V[1]*V[1]),3));
    U[3]=-M*G*(V[1]/pow(sqrt(V[0]*V[0]+V[1]*V[1]),3));
    return U;// renovyer un vecter de taille 1*4
}


double **trajectoire(double d, double v_init, double N,double*(*F)(double*V,double m,double g),double M,double G){
    // d est la distance initiale 6500km
    // v_init est la vitesse initiale du satellite (en km)
    // 
    double h=d*v_init;
    double**U=Zero(N+1,4);
    U[0][0]=d;
    U[0][3]=v_init;
    for (int i=0;i<N;i++){
        double*FUi=F(U[i],M,G); //F(U_i)
        double*hFUi=prv(FUi,h,4); //h*F(U_i)
        double*FUih=F((av(U[i],hFUi,4)),M,G); //F(U_i+h*F(U_i)
        //av(hFUi,FUih,4):=F(U_i)+F(U_i+h*F(U_i)    
        //prv(av(hFUi,FUih,4),h/2,4):=(h/2)*F(U_i)+F(U_i+h*F(U_i)
        U[i+1]=av(U[i],prv(av(hFUi,FUih,4),h/2,4),4);
    }
    return U;
}



int main(){
    double d=6500;
    double v_init=8;
    double N=50;
    double M=5.9722*pow(10,24);
    double G=6.6743*pow(10,-11);
    double* V=new double[3];
    V[0]=d;
    V[3]=v_init;
    print_m(trajectoire(d,v_init,N,&F,M,G),N,4);
    
    return 0;
}
